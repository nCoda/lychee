#--------------------------------------------------------------------------------------------------
# Program Name:           Lychee
# Program Description:    MEI document manager for formalized document control
#
# Filename:               lychee/converters/lilypond.ebnf
# Purpose:                LilyPond EBNF grammar for Grako
#
# Copyright (C) 2016 Christopher Antila
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.
#--------------------------------------------------------------------------------------------------
#
# NOTE for Lychee developers:
#
# The module "lychee.converters.lilypond_parser" is autogenerated from this file using Grako.
#
# Run this command in this directory to regenerate the "lilypond_parser" module after you update
# the EBNF grammar specification:
# $ python -m grako -c -o lilypond_parser.py lilypond.ebnf

@@comments :: /\%\{.*?\%\}/
# @@eol_comments :: /%.*?$/  # TODO: negative lookahead assertion for %{
@@grammar :: LilyPond
@@left_recursion :: False
@@parseinfo :: False


start = score | staff | staff_content ;


# Document
##########
version_stmt =
    '\\version' '"' @:'.'.{ /[0-9]*/ } '"'
    ;


# Staff Settings
################

instr_name =
    ly_type:`instr_name` '\\set' 'Staff.instrumentName' ~ '=' '"' name:/[A-Z a-z0-9&]*/ '"'
    ;

clef =
    ly_type:`clef` '\\clef' ~ '"' type:( 'bass' | 'tenor' | 'alto' | 'treble' ) '"'
    ;

key =
    ly_type:`key` '\\key' ~ keynote:pitch_name accid:[accidental_symbol] '\\' mode:( "major" | "minor" )
    ;

time_numerator = /[1-9][0-9]?/ ;
time =
    ly_type:`time` '\\time' ~ count:time_numerator '/' unit:duration_number
    ;

staff_setting =
    clef | key | time | instr_name
    ;


# Nodes: notes, rests, chords, spacers
######################################

pitch_name =
    /[a-g]/
    ;

octave =
    ",," | "," | "'''''" | "''''" | "'''" | "''" | "'"
    ;

accidental_symbol = /[ei]s/ ;
accidental = {accidental_symbol}* ;

accidental_force =
    '?' | '!'
    ;

duration_number =
    '512' | '256' | '128' | '64' | '32' | '16' | '8' | '4' | '2' | '1'
    ;

duration_dots =
    {'.'}*
    ;

duration =
    ( dur:duration_number {dots:duration_dots}+ ) |
    ( dur:duration_number dots:{} ) |
    ( dur:() dots:{} )
    ;

tie =
    ly_type:`tie`
    '~'
    ;

slur =
    ly_type:`slur`
    slur: ('(' | ')')
    ;

post_event =
    tie | slur
    ;

notehead =
    pname:pitch_name ~
    accid:accidental
    [oct:octave]
    [accid_force:accidental_force]
    ;

note =
    ly_type:`note`
    >notehead
    >duration
    post_events:{post_event}*
    ;

chord_note =
    >notehead
    post_events:{post_event}*
    ;

chord =
    ly_type:`chord`
    '<' !'<'
    notes:{chord_note}*
    '>'
    >duration
    post_events:{post_event}*
    ;

rest =
    ly_type:`rest` /r/ >duration post_events:{post_event}*
    ;

measure_rest =
    ly_type:`measure_rest` /R/ >duration post_events:{post_event}*
    ;

spacer =
    ly_type:`spacer` /s/ >duration post_events:{post_event}*
    ;

node = note | rest | measure_rest | chord | spacer | staff_setting ;
barcheck = ly_type:`barcheck` '|' ;

music_node = note | rest | chord | spacer ;
nodes = { >music_node | >staff_setting | barcheck }+ ;


# Layers
########

unmarked_layer =
    nodes
    ;
marked_layer =
    '{' @:nodes '}'
    ;

monophonic_layers =
    layers+:unmarked_layer
    ;
polyphonic_layers =
    simul_l layers:( '\\\'.{marked_layer} ) simul_r
    ;


# Staff and Music Block
#######################

brace_l = '{' ;
brace_r = '}' ;

staff_content =
    ly_type:`staff`
    initial_settings:{staff_setting}*
    content:{( monophonic_layers | polyphonic_layers )}+
    ;

token_new = '\\new' ;
token_staff = 'Staff' ;
staff =
    token_new token_staff brace_l
        >staff_content
    brace_r
    ;


# Score and Layout
# TODO: these rules are untested; probably need to be rewritten
##################

simul_l = '<<' ;
simul_r = '>>' ;

score_staff_content = simul_l ~ @:{staff}+ simul_r ;

layout_block = "\\layout" brace_l brace_r ;

token_score = '\\score' ;
score =
    ly_type:`score`
    version:[version_stmt]
    token_score brace_l
        staves:score_staff_content
        [layout_block:layout_block]
    brace_r
    ;
